-- Generated by CSharp.lua Compiler
local System = System
local Linq = System.Linq.Enumerable
local ET = ET
local ListType = System.List(System.Type)
local ListObject = System.List(System.Object)
local QueueInt64 = System.Queue(System.Int64)
local HashSetType = System.HashSet(System.Type)
local DictTypeInt32 = System.Dictionary(System.Type, System.Int32)
local DictTypeListObject = System.Dictionary(System.Type, ListObject)
local ET
local DictInt64Entity
local ListComponent_1ETTask
local UnOrderMultiMapSet_2TypeType
local UnOrderMultiMap_2TypeILoadSystem
local UnOrderMultiMap_2TypeIAwakeSystem
local UnOrderMultiMap_2TypeIStartSystem
local UnOrderMultiMap_2TypeIChangeSystem
local UnOrderMultiMap_2TypeIUpdateSystem
local UnOrderMultiMap_2TypeIDestroySystem
local UnOrderMultiMap_2TypeILateUpdateSystem
local UnOrderMultiMap_2TypeIDeserializeSystem
System.import(function (out)
  ET = out.ET
  DictInt64Entity = System.Dictionary(System.Int64, ET.Entity)
  ListComponent_1ETTask = ET.ListComponent_1(ET.ETTask)
  UnOrderMultiMapSet_2TypeType = ET.UnOrderMultiMapSet_2(System.Type, System.Type)
  UnOrderMultiMap_2TypeILoadSystem = ET.UnOrderMultiMap_2(System.Type, ET.ILoadSystem)
  UnOrderMultiMap_2TypeIAwakeSystem = ET.UnOrderMultiMap_2(System.Type, ET.IAwakeSystem)
  UnOrderMultiMap_2TypeIStartSystem = ET.UnOrderMultiMap_2(System.Type, ET.IStartSystem)
  UnOrderMultiMap_2TypeIChangeSystem = ET.UnOrderMultiMap_2(System.Type, ET.IChangeSystem)
  UnOrderMultiMap_2TypeIUpdateSystem = ET.UnOrderMultiMap_2(System.Type, ET.IUpdateSystem)
  UnOrderMultiMap_2TypeIDestroySystem = ET.UnOrderMultiMap_2(System.Type, ET.IDestroySystem)
  UnOrderMultiMap_2TypeILateUpdateSystem = ET.UnOrderMultiMap_2(System.Type, ET.ILateUpdateSystem)
  UnOrderMultiMap_2TypeIDeserializeSystem = ET.UnOrderMultiMap_2(System.Type, ET.IDeserializeSystem)
end)
System.namespace("ET", function (namespace)
  namespace.class("EventSystem", function (namespace)
    local instance, getInstance, AddType, Init, GetTypes, GetTypes1, RegisterSystem, Remove, 
    Get, IsRegister, Deserialize, Awake, Awake1, Awake2, Awake3, Awake4, 
    Change, Load, Start, Destroy, Update, LateUpdate, Publish, ToString, 
    Dispose, class, __ctor__
    __ctor__ = function (this)
      this.allComponents = DictInt64Entity()
      this.allTypes = ListType()
      this.types = UnOrderMultiMapSet_2TypeType()
      this.allEvents = DictTypeListObject()
      this.awakeSystems = UnOrderMultiMap_2TypeIAwakeSystem()
      this.startSystems = UnOrderMultiMap_2TypeIStartSystem()
      this.destroySystems = UnOrderMultiMap_2TypeIDestroySystem()
      this.loadSystems = UnOrderMultiMap_2TypeILoadSystem()
      this.updateSystems = UnOrderMultiMap_2TypeIUpdateSystem()
      this.lateUpdateSystems = UnOrderMultiMap_2TypeILateUpdateSystem()
      this.changeSystems = UnOrderMultiMap_2TypeIChangeSystem()
      this.deserializeSystems = UnOrderMultiMap_2TypeIDeserializeSystem()
      this.updates = QueueInt64()
      this.updates2 = QueueInt64()
      this.starts = QueueInt64()
      this.loaders = QueueInt64()
      this.loaders2 = QueueInt64()
      this.lateUpdates = QueueInt64()
      this.lateUpdates2 = QueueInt64()
      -- this.Add(typeof(EventSystem).Assembly);
    end
    getInstance = function ()
      if instance == nil then
        instance = class()
      end

      return instance
    end
    AddType = function (this, type)
      this.allTypes:Add(type)
    end
    Init = function (this)
      for _, type in System.each(this.allTypes) do
        local continue
        repeat

          local objects = type:GetCustomAttributes(System.typeof(ET.BaseAttribute), true)
          if #objects == 0 then
            continue = true
            break
          end

          for _, baseAttribute in System.each(objects) do
            baseAttribute = System.cast(ET.BaseAttribute, baseAttribute)
            this.types:Add(baseAttribute.AttributeType, type)
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end


      this.awakeSystems:Clear()
      this.lateUpdateSystems:Clear()
      this.updateSystems:Clear()
      this.startSystems:Clear()
      this.loadSystems:Clear()
      this.changeSystems:Clear()
      this.destroySystems:Clear()
      this.deserializeSystems:Clear()

      for _, type in System.each(GetTypes(this, System.typeof(ET.ObjectSystemAttribute))) do
        local obj = System.Activator.CreateInstance(type)
        repeat
          local default = obj
          if System.is(default, ET.IAwakeSystem) then
            this.awakeSystems:Add(default:Type(), default)
            break
          elseif System.is(default, ET.IUpdateSystem) then
            this.updateSystems:Add(default:Type(), default)
            break
          elseif System.is(default, ET.ILateUpdateSystem) then
            this.lateUpdateSystems:Add(default:Type(), default)
            break
          elseif System.is(default, ET.IStartSystem) then
            this.startSystems:Add(default:Type(), default)
            break
          elseif System.is(default, ET.IDestroySystem) then
            this.destroySystems:Add(default:Type(), default)
            break
          elseif System.is(default, ET.ILoadSystem) then
            this.loadSystems:Add(default:Type(), default)
            break
          elseif System.is(default, ET.IChangeSystem) then
            this.changeSystems:Add(default:Type(), default)
            break
          elseif System.is(default, ET.IDeserializeSystem) then
            this.deserializeSystems:Add(default:Type(), default)
            break
          end
        until 1
      end

      this.allEvents:Clear()
      ET.Log.Info(this.types:getCount() .. "  " .. this.types:get(System.typeof(ET.EventAttribute)):getCount())
      for _, type in System.each(this.types:get(System.typeof(ET.EventAttribute))) do
        local obj = System.as(System.Activator.CreateInstance(type), ET.IEvent)
        if obj == nil then
          System.throw(System.Exception("type not is AEvent: " .. obj:GetType():getName()))
        end

        local eventType = obj:GetEventType()
        if not this.allEvents:ContainsKey(eventType) then
          this.allEvents:AddKeyValue(eventType, ListObject())
        end

        this.allEvents:get(eventType):Add(obj)
      end

      Load(this)
    end
    GetTypes = function (this, systemAttributeType)
      if not this.types:ContainsKey(systemAttributeType) then
        return HashSetType()
      end

      return this.types:get(systemAttributeType)
    end
    GetTypes1 = function (this)
      return this.allTypes
    end
    RegisterSystem = function (this, component, isRegister)
      if not isRegister then
        Remove(this, component.InstanceId)
        return
      end

      this.allComponents:AddKeyValue(component.InstanceId, component)

      local type = component:GetType()

      if this.loadSystems:ContainsKey(type) then
        this.loaders:Enqueue(component.InstanceId)
      end

      if this.updateSystems:ContainsKey(type) then
        this.updates:Enqueue(component.InstanceId)
      end

      if this.startSystems:ContainsKey(type) then
        this.starts:Enqueue(component.InstanceId)
      end

      if this.lateUpdateSystems:ContainsKey(type) then
        this.lateUpdates:Enqueue(component.InstanceId)
      end
    end
    Remove = function (this, instanceId)
      this.allComponents:RemoveKey(instanceId)
    end
    Get = function (this, instanceId)
      local component = nil
      local _
      _, component = this.allComponents:TryGetValue(instanceId, nil)
      return component
    end
    IsRegister = function (this, instanceId)
      return this.allComponents:ContainsKey(instanceId)
    end
    Deserialize = function (this, component)
      local iDeserializeSystems = this.deserializeSystems:get(component:GetType())
      if iDeserializeSystems == nil then
        return
      end

      for _, deserializeSystem in System.each(iDeserializeSystems) do
        local continue
        repeat
          if deserializeSystem == nil then
            continue = true
            break
          end

          System.try(function ()
            deserializeSystem:Run(component)
          end, function (default)
            local e = default
            ET.Log.Error1(e)
          end)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Awake = function (this, component)
      local iAwakeSystems = this.awakeSystems:get(component:GetType())
      if iAwakeSystems == nil then
        return
      end

      for _, aAwakeSystem in System.each(iAwakeSystems) do
        local continue
        repeat
          if aAwakeSystem == nil then
            continue = true
            break
          end

          local iAwake = System.as(aAwakeSystem, ET.IAwake)
          if iAwake == nil then
            continue = true
            break
          end

          System.try(function ()
            iAwake:Run(component)
          end, function (default)
            local e = default
            ET.Log.Error1(e)
          end)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Awake1 = function (this, component, p1, P1)
      local iAwakeSystems = this.awakeSystems:get(component:GetType())
      if iAwakeSystems == nil then
        return
      end

      for _, aAwakeSystem in System.each(iAwakeSystems) do
        local continue
        repeat
          if aAwakeSystem == nil then
            continue = true
            break
          end

          local iAwake = System.as(aAwakeSystem, ET.IAwake_1(P1))
          if iAwake == nil then
            continue = true
            break
          end

          System.try(function ()
            iAwake:Run(component, p1)
          end, function (default)
            local e = default
            ET.Log.Error1(e)
          end)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Awake2 = function (this, component, p1, p2, P1, P2)
      local iAwakeSystems = this.awakeSystems:get(component:GetType())
      if iAwakeSystems == nil then
        return
      end

      for _, aAwakeSystem in System.each(iAwakeSystems) do
        local continue
        repeat
          if aAwakeSystem == nil then
            continue = true
            break
          end

          local iAwake = System.as(aAwakeSystem, ET.IAwake_2(P1, P2))
          if iAwake == nil then
            continue = true
            break
          end

          System.try(function ()
            iAwake:Run(component, p1, p2)
          end, function (default)
            local e = default
            ET.Log.Error1(e)
          end)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Awake3 = function (this, component, p1, p2, p3, P1, P2, P3)
      local iAwakeSystems = this.awakeSystems:get(component:GetType())
      if iAwakeSystems == nil then
        return
      end

      for _, aAwakeSystem in System.each(iAwakeSystems) do
        local continue
        repeat
          if aAwakeSystem == nil then
            continue = true
            break
          end

          local iAwake = System.as(aAwakeSystem, ET.IAwake_3(P1, P2, P3))
          if iAwake == nil then
            continue = true
            break
          end

          System.try(function ()
            iAwake:Run(component, p1, p2, p3)
          end, function (default)
            local e = default
            ET.Log.Error1(e)
          end)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Awake4 = function (this, component, p1, p2, p3, p4, P1, P2, P3, P4)
      local iAwakeSystems = this.awakeSystems:get(component:GetType())
      if iAwakeSystems == nil then
        return
      end

      for _, aAwakeSystem in System.each(iAwakeSystems) do
        local continue
        repeat
          if aAwakeSystem == nil then
            continue = true
            break
          end

          local iAwake = System.as(aAwakeSystem, ET.IAwake_4(P1, P2, P3, P4))
          if iAwake == nil then
            continue = true
            break
          end

          System.try(function ()
            iAwake:Run(component, p1, p2, p3, p4)
          end, function (default)
            local e = default
            ET.Log.Error1(e)
          end)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Change = function (this, component)
      local iChangeSystems = this.changeSystems:get(component:GetType())
      if iChangeSystems == nil then
        return
      end

      for _, iChangeSystem in System.each(iChangeSystems) do
        local continue
        repeat
          if iChangeSystem == nil then
            continue = true
            break
          end

          System.try(function ()
            iChangeSystem:Run(component)
          end, function (default)
            local e = default
            ET.Log.Error1(e)
          end)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Load = function (this)
      while #this.loaders > 0 do
        local continue
        repeat
          local instanceId = this.loaders:Dequeue()
          local component
          local default
          default, component = this.allComponents:TryGetValue(instanceId, nil)
          if not default then
            continue = true
            break
          end

          if component:getIsDisposed() then
            continue = true
            break
          end

          local iLoadSystems = this.loadSystems:get(component:GetType())
          if iLoadSystems == nil then
            continue = true
            break
          end

          this.loaders2:Enqueue(instanceId)

          for _, iLoadSystem in System.each(iLoadSystems) do
            System.try(function ()
              iLoadSystem:Run(component)
            end, function (default)
              local e = default
              ET.Log.Error1(e)
            end)
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      this.loaders, this.loaders2 = ET.ObjectHelper.Swap(this.loaders, this.loaders2, QueueInt64)
    end
    Start = function (this)
      while #this.starts > 0 do
        local continue
        repeat
          local instanceId = this.starts:Dequeue()
          local component
          local default
          default, component = this.allComponents:TryGetValue(instanceId, nil)
          if not default then
            continue = true
            break
          end

          local iStartSystems = this.startSystems:get(component:GetType())
          if iStartSystems == nil then
            continue = true
            break
          end

          for _, iStartSystem in System.each(iStartSystems) do
            System.try(function ()
              iStartSystem:Run(component)
            end, function (default)
              local e = default
              ET.Log.Error1(e)
            end)
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Destroy = function (this, component)
      local iDestroySystems = this.destroySystems:get(component:GetType())
      if iDestroySystems == nil then
        return
      end

      for _, iDestroySystem in System.each(iDestroySystems) do
        local continue
        repeat
          if iDestroySystem == nil then
            continue = true
            break
          end

          System.try(function ()
            iDestroySystem:Run(component)
          end, function (default)
            local e = default
            ET.Log.Error1(e)
          end)
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    Update = function (this)
      Start(this)

      while #this.updates > 0 do
        local continue
        repeat
          local instanceId = this.updates:Dequeue()
          local component
          local default
          default, component = this.allComponents:TryGetValue(instanceId, nil)
          if not default then
            continue = true
            break
          end

          if component:getIsDisposed() then
            continue = true
            break
          end

          local iUpdateSystems = this.updateSystems:get(component:GetType())
          if iUpdateSystems == nil then
            continue = true
            break
          end

          this.updates2:Enqueue(instanceId)

          for _, iUpdateSystem in System.each(iUpdateSystems) do
            System.try(function ()
              iUpdateSystem:Run(component)
            end, function (default)
              local e = default
              ET.Log.Error1(e)
            end)
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      this.updates, this.updates2 = ET.ObjectHelper.Swap(this.updates, this.updates2, QueueInt64)
    end
    LateUpdate = function (this)
      while #this.lateUpdates > 0 do
        local continue
        repeat
          local instanceId = this.lateUpdates:Dequeue()
          local component
          local default
          default, component = this.allComponents:TryGetValue(instanceId, nil)
          if not default then
            continue = true
            break
          end

          if component:getIsDisposed() then
            continue = true
            break
          end

          local iLateUpdateSystems = this.lateUpdateSystems:get(component:GetType())
          if iLateUpdateSystems == nil then
            continue = true
            break
          end

          this.lateUpdates2:Enqueue(instanceId)

          for _, iLateUpdateSystem in System.each(iLateUpdateSystems) do
            System.try(function ()
              iLateUpdateSystem:Run(component)
            end, function (default)
              local e = default
              ET.Log.Error1(e)
            end)
          end
          continue = true
        until 1
        if not continue then
          break
        end
      end

      this.lateUpdates, this.lateUpdates2 = ET.ObjectHelper.Swap(this.lateUpdates, this.lateUpdates2, QueueInt64)
    end
    Publish = function (this, a, T)
      return System.async(function (async, this, a, T)
        local iEvents
        local default
        default, iEvents = this.allEvents:TryGetValue(System.typeof(T), nil)
        if not default then
          return
        end

        System.using(ListComponent_1ETTask.Create(), function (list)

          for _, obj in System.each(iEvents) do
            local continue
            repeat
              local aEvent = obj
              if not (System.is(aEvent, ET.AEvent_1(T))) then
                ET.Log.Error("event error: " .. obj:GetType():getName())
                continue = true
                break
              end

              list.List:Add(aEvent:Handle(a:__clone__()))
              continue = true
            until 1
            if not continue then
              break
            end
          end

          System.try(function ()
            async:Await(ET.ETTaskHelper.WaitAll3(list.List))
          end, function (default)
            local e = default
            ET.Log.Error1(e)
          end)
        end)
      end, nil, this, a, T)
    end
    ToString = function (this)
      local sb = System.StringBuilder()
      local noParent = HashSetType()
      local typeCount = DictTypeInt32()

      local noDomain = HashSetType()

      for _, kv in System.each(this.allComponents) do
        local type = kv[2]:GetType()
        if kv[2]:getParent() == nil then
          noParent:Add(type)
        end

        if kv[2]:getDomain() == nil then
          noDomain:Add(type)
        end

        if typeCount:ContainsKey(type) then
          local default = typeCount
          default:set(type, default:get(type) + 1)
        else
          typeCount:set(type, 1)
        end
      end

      sb:AppendLine("not set parent type: ")
      for _, type in System.each(noParent) do
        sb:AppendLine("\t" .. type:getName())
      end

      sb:AppendLine("not set domain type: ")
      for _, type in System.each(noDomain) do
        sb:AppendLine("\t" .. type:getName())
      end

      local orderByDescending = Linq.OrderByDescending(typeCount, function (s)
        return s[2]
      end, nil, System.Int32)

      sb:AppendLine("Entity Count: ")
      for _, kv in System.each(orderByDescending) do
        local continue
        repeat
          if kv[2] == 1 then
            continue = true
            break
          end

          sb:AppendLine("\t" .. kv[1]:getName() .. ": " .. kv[2])
          continue = true
        until 1
        if not continue then
          break
        end
      end

      return sb:ToString()
    end
    Dispose = function (this)
      instance = nil
    end
    class = {
      base = function (out)
        return {
          System.IDisposable
        }
      end,
      getInstance = getInstance,
      AddType = AddType,
      Init = Init,
      GetTypes = GetTypes,
      GetTypes1 = GetTypes1,
      RegisterSystem = RegisterSystem,
      Remove = Remove,
      Get = Get,
      IsRegister = IsRegister,
      Deserialize = Deserialize,
      Awake = Awake,
      Awake1 = Awake1,
      Awake2 = Awake2,
      Awake3 = Awake3,
      Awake4 = Awake4,
      Change = Change,
      Load = Load,
      Destroy = Destroy,
      Update = Update,
      LateUpdate = LateUpdate,
      Publish = Publish,
      ToString = ToString,
      Dispose = Dispose,
      __ctor__ = __ctor__
    }
    return class
  end)
end)
