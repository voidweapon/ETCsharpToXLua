-- Generated by CSharp.lua Compiler
local System = System
local Linq = System.Linq.Enumerable
local SystemNetSockets = System.Net.Sockets
local HashSetInt64 = System.HashSet(System.Int64)
local ET
local DictInt64TChannel
System.import(function (out)
  ET = out.ET
  DictInt64TChannel = System.Dictionary(System.Int64, ET.TChannel)
end)
System.namespace("ET", function (namespace)
  namespace.class("TService", function (namespace)
    local OnComplete, OnAcceptComplete, AcceptAsync, Create, Get, Get1, Dispose, Remove, 
    Send, Update, IsDispose, internal, __ctor1__, __ctor2__
    internal = function (this)
      this.idChannels = DictInt64TChannel()
      this.innArgs = SystemNetSockets.SocketAsyncEventArgs()
      this.NeedStartSend = HashSetInt64()
    end
    __ctor1__ = function (this, threadSynchronizationContext, serviceType)
      internal(this)
      System.base(this).__ctor__(this)
      this.ServiceType = serviceType
      this.ThreadSynchronizationContext = threadSynchronizationContext
    end
    __ctor2__ = function (this, threadSynchronizationContext, ipEndPoint, serviceType)
      internal(this)
      System.base(this).__ctor__(this)
      this.ServiceType = serviceType
      this.ThreadSynchronizationContext = threadSynchronizationContext

      this.acceptor = SystemNetSockets.Socket(SystemNetSockets.AddressFamily.InterNetwork, SystemNetSockets.SocketType.Stream, SystemNetSockets.ProtocolType.Tcp)
      this.acceptor:SetSocketOption(SystemNetSockets.SocketOptionLevel.Socket, SystemNetSockets.SocketOptionName.ReuseAddress, true)
      this.innArgs:addCompleted(System.fn(this, OnComplete))
      this.acceptor:Bind(ipEndPoint)
      this.acceptor:Listen(1000)

      this.ThreadSynchronizationContext:PostNext(System.fn(this, AcceptAsync))
    end
    OnComplete = function (this, sender, e)
      repeat
        local default = e:getLastOperation()
        if default == SystemNetSockets.SocketAsyncOperation.Accept then
          local socketError = e:getSocketError()
          local acceptSocket = e:getAcceptSocket()
          this.ThreadSynchronizationContext:Post(function ()
            OnAcceptComplete(this, socketError, acceptSocket)
          end)
          break
        else
          System.throw(System.Exception("socket error: " .. e:getLastOperation():EnumToString(SystemNetSockets.SocketAsyncOperation)))
        end
      until 1
    end
    OnAcceptComplete = function (this, socketError, acceptSocket)
      if this.acceptor == nil then
        return
      end

      -- 开始新的accept
      AcceptAsync(this)

      if socketError ~= SystemNetSockets.SocketError.Success then
        ET.Log.Error("accept error " .. socketError:EnumToString(SystemNetSockets.SocketError))
        return
      end

      System.try(function ()
        local id = this:CreateAcceptChannelId(0)
        local channel = System.new(ET.TChannel, 2, id, acceptSocket, this)
        this.idChannels:AddKeyValue(channel.Id, channel)
        local channelId = channel.Id

        this:OnAccept(channelId, channel.RemoteAddress)
      end, function (default)
        local exception = default
        ET.Log.Error1(exception)
      end)
    end
    AcceptAsync = function (this)
      this.innArgs:setAcceptSocket(nil)
      if this.acceptor:AcceptAsync(this.innArgs) then
        return
      end
      OnAcceptComplete(this, this.innArgs:getSocketError(), this.innArgs:getAcceptSocket())
    end
    Create = function (this, ipEndPoint, id)
      local channel = ET.TChannel(id, ipEndPoint, this)
      this.idChannels:AddKeyValue(channel.Id, channel)
      return channel
    end
    Get = function (this, id, address)
      local default, _ = this.idChannels:TryGetValue(id)
      if default then
        return
      end
      Create(this, address, id)
    end
    Get1 = function (this, id)
      local channel = nil
      local _
      _, channel = this.idChannels:TryGetValue(id)
      return channel
    end
    Dispose = function (this)
      local default = this.acceptor
      if default ~= nil then
        default:Close()
      end
      this.acceptor = nil
      this.innArgs:Dispose()
      this.ThreadSynchronizationContext = nil

      for _, id in System.each(Linq.ToArray(this.idChannels:getKeys())) do
        local channel = this.idChannels:get(id)
        channel:Dispose()
      end
      this.idChannels:Clear()
    end
    Remove = function (this, id)
      local default, channel = this.idChannels:TryGetValue(id)
      if default then
        channel:Dispose()
      end

      this.idChannels:RemoveKey(id)
    end
    Send = function (this, channelId, actorId, stream)
      local default = System.try(function ()
        local aChannel = Get1(this, channelId)
        if aChannel == nil then
          this:OnError(channelId, 100213 --[[ErrorCode.ERR_SendMessageNotFoundTChannel]])
          return true
        end
        aChannel:Send(actorId, stream)
      end, function (default)
        local e = default
        ET.Log.Error1(e)
      end)
      if default then
        return
      end
    end
    Update = function (this)
      for _, channelId in System.each(this.NeedStartSend) do
        local tChannel = Get1(this, channelId)
        local default = tChannel
        if default ~= nil then
          default:Update()
        end
      end
      this.NeedStartSend:Clear()
    end
    IsDispose = function (this)
      return this.ThreadSynchronizationContext == nil
    end
    return {
      base = function (out)
        return {
          out.ET.AService
        }
      end,
      Get = Get,
      Dispose = Dispose,
      Remove = Remove,
      Send = Send,
      Update = Update,
      IsDispose = IsDispose,
      __ctor__ = {
        __ctor1__,
        __ctor2__
      }
    }
  end)
end)
