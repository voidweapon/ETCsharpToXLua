-- Generated by CSharp.lua Compiler
local System = System
local Linq = System.Linq.Enumerable
local ET = ET
local ETCold = ETCold
local SystemIO = System.IO
local UnityEngine = UnityEngine
local ListInt32 = System.List(System.Int32)
local ListString = System.List(System.String)
local ArrayObject = System.Array(UnityEngine.Object)
local ArrayString = System.Array(System.String)
local DictInt32String = System.Dictionary(System.Int32, System.String)
local DictStringInt32 = System.Dictionary(System.String, System.Int32)
local DictStringObject = System.Dictionary(System.String, UnityEngine.Object)
local DictStringString = System.Dictionary(System.String, System.String)
local ETTask_1ArrayObject = ET.ETTask_1(ArrayObject)
local ETTask_1AssetBundle = ET.ETTask_1(UnityEngine.AssetBundle)
local DictStringArrayString = System.Dictionary(System.String, ArrayString)
local DictStringDictStringObject = System.Dictionary(System.String, DictStringObject)
local ET
local DictStringABInfo
local ListComponent_1ABInfo
local ListComponent_1ETTask
System.import(function (out)
  ET = out.ET
  DictStringABInfo = System.Dictionary(System.String, ET.ABInfo)
  ListComponent_1ABInfo = ET.ListComponent_1(ET.ABInfo)
  ListComponent_1ETTask = ET.ListComponent_1(ET.ETTask)
end)
System.namespace("ET", function (namespace)
  namespace.class("ABInfoAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self, abName, a)
      self.AssetBundle = a
      self.Name = abName
      self.RefCount = 1
      self.AlreadyLoadAssets = false
    end
    return {
      base = function (out)
        return {
          out.ET.AwakeSystem_3(out.ET.ABInfo, System.String, out.UnityEngine.AssetBundle)
        }
      end,
      Awake = Awake,
      __metadata__ = function (out)
        return {
          class = { 0x6, out.ET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("ABInfoDestroySystem", function (namespace)
    local Destroy
    Destroy = function (this, self)
      --Log.Debug($"desdroy assetbundle: {this.Name}");

      self.RefCount = 0
      self.Name = ""
      self.AlreadyLoadAssets = false
      self.AssetBundle = nil
    end
    return {
      base = function (out)
        return {
          out.ET.DestroySystem_1(out.ET.ABInfo)
        }
      end,
      Destroy = Destroy,
      __metadata__ = function (out)
        return {
          class = { 0x6, out.ET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("ABInfo", function (namespace)
    local Destroy, __ctor__
    __ctor__ = function (this)
      ET.Entity.__ctor__(this)
    end
    Destroy = function (this, unload)
      if UnityEngine.Object.op_Inequality(this.AssetBundle, nil) then
        this.AssetBundle:Unload(unload)
      end

      this:Dispose()
    end
    return {
      base = function (out)
        return {
          out.ET.Entity
        }
      end,
      RefCount = 0,
      AlreadyLoadAssets = false,
      Destroy = Destroy,
      __ctor__ = __ctor__
    }
  end)

  -- 用于字符串转换，减少GC
  namespace.class("AssetBundleHelper", function (namespace)
    local UnityLoadBundleAsync, UnityLoadAssetAsync, IntToString, StringToAB, IntToAB, BundleNameToLower
    UnityLoadBundleAsync = function (path)
      return System.async(function (async, path)
        local tcs = ETTask_1AssetBundle.Create(true)
        local request = UnityEngine.AssetBundle.LoadFromFileAsync(path)
        request:addcompleted(function (operation)
          tcs:SetResult(request:getassetBundle())
        end)
        return async:Await(tcs)
      end, nil, path)
    end
    UnityLoadAssetAsync = function (assetBundle)
      return System.async(function (async, assetBundle)
        local tcs = ETTask_1ArrayObject.Create(true)
        local request = assetBundle:LoadAllAssetsAsync()
        request:addcompleted(function (operation)
          tcs:SetResult(request:getallAssets())
        end)
        return async:Await(tcs)
      end, nil, assetBundle)
    end
    IntToString = function (value)
      local result
      local default
      default, result = ET.ResourcesComponent.Instance.IntToStringDict:TryGetValue(value, nil)
      if default then
        return result
      end

      result = value:ToString()
      ET.ResourcesComponent.Instance.IntToStringDict:set(value, result)
      return result
    end
    StringToAB = function (value)
      local result
      local default
      default, result = ET.ResourcesComponent.Instance.StringToABDict:TryGetValue(value, nil)
      if default then
        return result
      end

      result = value .. ".unity3d"
      ET.ResourcesComponent.Instance.StringToABDict:set(value, result)
      return result
    end
    IntToAB = function (value)
      return StringToAB(IntToString(value))
    end
    BundleNameToLower = function (value)
      local result
      local default
      default, result = ET.ResourcesComponent.Instance.BundleNameToLowerDict:TryGetValue(value, nil)
      if default then
        return result
      end

      result = value:ToLower()
      ET.ResourcesComponent.Instance.BundleNameToLowerDict:set(value, result)
      return result
    end
    return {
      UnityLoadBundleAsync = UnityLoadBundleAsync,
      UnityLoadAssetAsync = UnityLoadAssetAsync,
      IntToString = IntToString,
      StringToAB = StringToAB,
      IntToAB = IntToAB,
      BundleNameToLower = BundleNameToLower
    }
  end)

  namespace.class("ResourcesComponentAwakeSystem", function (namespace)
    local Awake
    Awake = function (this, self)
      self:Awake()
    end
    return {
      base = function (out)
        return {
          out.ET.AwakeSystem_1(out.ET.ResourcesComponent)
        }
      end,
      Awake = Awake,
      __metadata__ = function (out)
        return {
          class = { 0x6, out.ET.ObjectSystemAttribute() }
        }
      end
    }
  end)

  namespace.class("ResourcesComponent", function (namespace)
    local Awake, Dispose, GetDependencies, GetSortedDependencies, CollectDependencies, Contains, GetBundleAll, GetAsset, 
    UnloadBundles, UnloadBundle, UnloadOneBundle, LoadBundle, AddResource, LoadOneBundle, LoadBundleAsync, LoadOneBundleAsync, 
    LoadOneBundleAllAssets, DebugString, class, __ctor__
    __ctor__ = function (this)
      this.IntToStringDict = DictInt32String()
      this.StringToABDict = DictStringString()
      local default = DictStringString()
      default:AddKeyValue("StreamingAssets", "StreamingAssets")
      this.BundleNameToLowerDict = default
      this.resourceCache = DictStringDictStringObject()
      this.bundles = DictStringABInfo()
      this.DependenciesCache = DictStringArrayString()
      ET.Entity.__ctor__(this)
    end
    Awake = function (this)
      class.Instance = this

      if ET.Define.IsAsync then
        LoadOneBundle(this, "StreamingAssets")
        this.AssetBundleManifestObject = System.cast(UnityEngine.AssetBundleManifest, GetAsset(this, "StreamingAssets", "AssetBundleManifest"))
      end
    end
    Dispose = function (this)
      if this:getIsDisposed() then
        return
      end

      ET.Entity.Dispose(this)

      class.Instance = nil

      for _, abInfo in System.each(this.bundles) do
        abInfo[2]:Destroy(true)
      end

      this.bundles:Clear()
      this.resourceCache:Clear()
      this.IntToStringDict:Clear()
      this.StringToABDict:Clear()
      this.BundleNameToLowerDict:Clear()
    end
    GetDependencies = function (this, assetBundleName)
      local dependencies = ArrayString(0)

      local default
      default, dependencies = this.DependenciesCache:TryGetValue(assetBundleName, nil)
      if default then
        return dependencies
      end

      if not ET.Define.IsAsync then
        local dependenciesList = ListString()
        local count = ETCold.LoadHelper.GetAssetBundleDependenciesCount(assetBundleName, true)
        local userDat = ETCold.LoadHelper.GetAssetBundleDependencies(assetBundleName, true)
        for i = 0, count - 1 do
          dependenciesList:Add(System.cast(System.String, userDat:GetValue(count)))
        end
        dependencies = dependenciesList:ToArray()
      else
        dependencies = this.AssetBundleManifestObject:GetAllDependencies(assetBundleName)
      end

      this.DependenciesCache:AddKeyValue(assetBundleName, dependencies)
      return dependencies
    end
    GetSortedDependencies = function (this, assetBundleName)
      local info = DictStringInt32()
      local parents = ListString()
      CollectDependencies(this, parents, assetBundleName, info)

      local keysResultArr = ListString()
      local keysArr = Linq.ToList(info:getKeys())
      local ValuesArr = Linq.ToList(info:getValues())
      local indexSet = ListInt32()
      local i = 0
      while i < #ValuesArr do
        local continue
        repeat
          local minIndex = 0
          local minValue = ValuesArr:get(0)
          for j = 0, #ValuesArr - 1 do
            local continue
            repeat
              if indexSet:Contains(j) then
                continue = true
                break
              end

              if ValuesArr:get(j) < minValue then
                minIndex = j
              end
              continue = true
            until 1
            if not continue then
              break
            end
          end
          indexSet:Add(minIndex)
          i = i + 1
          continue = true
        until 1
        if not continue then
          break
        end
      end

      for j = 0, #indexSet - 1 do
        keysResultArr:Add(keysArr:get(indexSet:get(j)))
      end
      local ss = keysResultArr:ToArray()
      return ss
    end
    CollectDependencies = function (this, parents, assetBundleName, info)
      parents:Add(assetBundleName)
      local deps = GetDependencies(this, assetBundleName)
      for _, parent in System.each(parents) do
        if not info:ContainsKey(parent) then
          info:set(parent, 0)
        end

        info:set(parent, info:get(parent) + #deps)
      end

      for _, dep in System.each(deps) do
        if parents:Contains(dep) then
          System.throw(System.Exception("包有循环依赖，请重新标记: " .. assetBundleName .. " " .. dep))
        end

        CollectDependencies(this, parents, dep, info)
      end

      parents:RemoveAt(#parents - 1)
    end
    Contains = function (this, bundleName)
      return this.bundles:ContainsKey(bundleName)
    end
    GetBundleAll = function (this, bundleName)
      if not this.resourceCache:ContainsKey(ET.AssetBundleHelper.BundleNameToLower(bundleName)) then
        System.throw(System.Exception("not found asset: " .. bundleName))
      end
      return this.resourceCache:get(ET.AssetBundleHelper.BundleNameToLower(bundleName))
    end
    GetAsset = function (this, bundleName, prefab)
      local dict
      local default
      default, dict = this.resourceCache:TryGetValue(ET.AssetBundleHelper.BundleNameToLower(bundleName), nil)
      if not default then
        System.throw(System.Exception("not found asset: " .. bundleName .. " " .. prefab))
      end

      local resource = nil
      local extern
      extern, resource = dict:TryGetValue(prefab, nil)
      if not extern then
        System.throw(System.Exception("not found asset: " .. bundleName .. " " .. prefab))
      end

      return resource
    end
    UnloadBundles = function (this, bundleList, unload)
      return System.async(function (async, this, bundleList, unload)
        local i = 0
        for _, bundle in System.each(bundleList) do
          System.using(async:Await(ET.CoroutineLockComponent.Instance:Wait(ET.CoroutineLockType.Resources, bundle:GetHashCode(), 60000)), function ()
            i = i + 1
            if System.mod(i, 5) == 0 then
              async:Await(ET.TimerComponent.Instance:WaitFrameAsync())
            end

            UnloadBundle(this, bundle, unload)
          end)
        end
      end, nil, this, bundleList, unload)
    end
    UnloadBundle = function (this, assetBundleName, unload)
      assetBundleName = ET.AssetBundleHelper.BundleNameToLower(assetBundleName)

      local dependencies = GetSortedDependencies(this, assetBundleName)

      --Log.Debug($"-----------dep unload start {assetBundleName} dep: {dependencies.ToList().ListToString()}");
      for _, dependency in System.each(dependencies) do
        UnloadOneBundle(this, dependency, unload)
      end

      --Log.Debug($"-----------dep unload finish {assetBundleName} dep: {dependencies.ToList().ListToString()}");
    end
    UnloadOneBundle = function (this, assetBundleName, unload)
      assetBundleName = ET.AssetBundleHelper.BundleNameToLower(assetBundleName)

      local abInfo
      local default
      default, abInfo = this.bundles:TryGetValue(assetBundleName, nil)
      if not default then
        return
      end

      --Log.Debug($"---------------unload one bundle {assetBundleName} refcount: {abInfo.RefCount - 1}");

      local extern = abInfo
      extern.RefCount = extern.RefCount - 1

      if abInfo.RefCount > 0 then
        return
      end

      --Log.Debug($"---------------truly unload one bundle {assetBundleName} refcount: {abInfo.RefCount}");
      this.bundles:RemoveKey(assetBundleName)
      this.resourceCache:RemoveKey(assetBundleName)
      abInfo:Destroy(unload)
      -- Log.Debug($"cache count: {this.cacheDictionary.Count}");
    end
    -- <summary>
    -- 同步加载assetbundle
    -- </summary>
    -- <param name="assetBundleName"></param>
    -- <returns></returns>
    LoadBundle = function (this, assetBundleName)
      assetBundleName = assetBundleName:ToLower()

      local dependencies = GetSortedDependencies(this, assetBundleName)

      for i = 0, #dependencies - 1 do
        local continue
        repeat
          if System.String.IsNullOrEmpty(dependencies:get(i)) then
            continue = true
            break
          end

          LoadOneBundle(this, dependencies:get(i))
          continue = true
        until 1
        if not continue then
          break
        end
      end
    end
    AddResource = function (this, bundleName, assetName, resource)
      local dict
      local default
      default, dict = this.resourceCache:TryGetValue(ET.AssetBundleHelper.BundleNameToLower(bundleName), nil)
      if not default then
        dict = DictStringObject()
        this.resourceCache:set(bundleName, dict)
      end

      dict:set(assetName, resource)
    end
    LoadOneBundle = function (this, assetBundleName)
      assetBundleName = ET.AssetBundleHelper.BundleNameToLower(assetBundleName)
      local abInfo
      local default
      default, abInfo = this.bundles:TryGetValue(assetBundleName, nil)
      if default then
        local extern = abInfo
        extern.RefCount = extern.RefCount + 1
        --Log.Debug($"---------------load one bundle {assetBundleName} refcount: {abInfo.RefCount}");
        return
      end

      if not ET.Define.IsAsync then
        if UnityEngine.Application.getisEditor() then
          --string[] realPath = null;

          local length = ETCold.LoadHelper.GetAssetPathsFromAssetBundleCount(assetBundleName)
          local realPathArr = ETCold.LoadHelper.GetAssetPathsFromAssetBundle(assetBundleName)

          for i = 0, length - 1 do
            local s = System.cast(System.String, realPathArr:GetValue(i))
            ET.Log.Debug(s)
            local assetName = SystemIO.Path.GetFileNameWithoutExtension(s)
            local resource = ETCold.LoadHelper.LoadAssetAtPath(s)
            -- AssetDatabase.LoadAssetAtPath<UnityEngine.Object>(s);
            AddResource(this, assetBundleName, assetName, resource)
          end

          if length > 0 then
            abInfo = ET.EntityFactory.CreateWithParent2(this, assetBundleName, nil, false, ET.ABInfo, System.String, UnityEngine.AssetBundle)
            this.bundles:set(assetBundleName, abInfo)
            --Log.Debug($"---------------load one bundle {assetBundleName} refcount: {abInfo.RefCount}");
          else
            ET.Log.Error("assets bundle not found: " .. assetBundleName)
          end
        end
        return
      end
      local p = SystemIO.Path.Combine(ET.PathHelper.getAppHotfixResPath(), assetBundleName)
      local assetBundle = nil
      if SystemIO.File.Exists(p) then
        assetBundle = UnityEngine.AssetBundle.LoadFromFile(p)
      else
        p = SystemIO.Path.Combine(ET.PathHelper.getAppResPath(), assetBundleName)
        assetBundle = UnityEngine.AssetBundle.LoadFromFile(p)
      end

      if UnityEngine.Object.op_Equality(assetBundle, nil) then
        -- 获取资源的时候会抛异常，这个地方不直接抛异常，因为有些地方需要Load之后判断是否Load成功
        ET.Log.Warning("assets bundle not found: " .. assetBundleName)
        return
      end

      if not assetBundle:getisStreamedSceneAssetBundle() then
        -- 异步load资源到内存cache住
        local assets = assetBundle:LoadAllAssets()
        for _, asset in System.each(assets) do
          AddResource(this, assetBundleName, asset:getname(), asset)
        end
      end

      abInfo = ET.EntityFactory.CreateWithParent2(this, assetBundleName, assetBundle, false, ET.ABInfo, System.String, UnityEngine.AssetBundle)
      this.bundles:set(assetBundleName, abInfo)

      --Log.Debug($"---------------load one bundle {assetBundleName} refcount: {abInfo.RefCount}");
    end
    -- <summary>
    -- 异步加载assetbundle, 加载ab包分两部分，第一部分是从硬盘加载，第二部分加载all assets。两者不能同时并发
    -- </summary>
    LoadBundleAsync = function (this, assetBundleName)
      return System.async(function (async, this, assetBundleName)
        assetBundleName = ET.AssetBundleHelper.BundleNameToLower(assetBundleName)

        local dependencies = GetSortedDependencies(this, assetBundleName)
        --Log.Debug($"-----------dep load async start {assetBundleName} dep: {dependencies.ToList().ListToString()}");

        System.using(ListComponent_1ABInfo.Create(), function (abInfos)
          local LoadDependency
          LoadDependency = function (dependency, abInfosList)
            return System.async(function (async, dependency, abInfosList)
              local default, extern = System.using(async:Await(ET.CoroutineLockComponent.Instance:Wait(ET.CoroutineLockType.Resources, dependency:GetHashCode(), 60000)), function ()
                local abInfo = async:Await(LoadOneBundleAsync(this, dependency))
                if abInfo == nil or abInfo.RefCount > 1 then
                  return true
                end

                abInfosList:Add(abInfo)
              end)
              if default then
                return extern
              end
            end, nil, dependency, abInfosList)
          end

          -- LoadFromFileAsync部分可以并发加载
          System.using(ListComponent_1ETTask.Create(), function (tasks)
            for _, dependency in System.each(dependencies) do
              tasks.List:Add(LoadDependency(dependency, abInfos.List))
            end

            async:Await(ET.ETTaskHelper.WaitAll3(tasks.List))
          end)

          -- ab包从硬盘加载完成，可以再并发加载all assets
          System.using(ListComponent_1ETTask.Create(), function (tasks)
            for _, abInfo in System.each(abInfos.List) do
              tasks.List:Add(LoadOneBundleAllAssets(this, abInfo))
            end

            async:Await(ET.ETTaskHelper.WaitAll3(tasks.List))
          end)
        end)
      end, nil, this, assetBundleName)
    end
    LoadOneBundleAsync = function (this, assetBundleName)
      return System.async(function (async, this, assetBundleName)
        assetBundleName = ET.AssetBundleHelper.BundleNameToLower(assetBundleName)
        local abInfo
        local default
        default, abInfo = this.bundles:TryGetValue(assetBundleName, nil)
        if default then
          local extern = abInfo
          extern.RefCount = extern.RefCount + 1
          --Log.Debug($"---------------load one bundle {assetBundleName} refcount: {abInfo.RefCount}");
          return nil
        end

        local p = ""
        local assetBundle = nil

        if not ET.Define.IsAsync then
          return abInfo
        end

        p = SystemIO.Path.Combine(ET.PathHelper.getAppHotfixResPath(), assetBundleName)
        if not SystemIO.File.Exists(p) then
          p = SystemIO.Path.Combine(ET.PathHelper.getAppResPath(), assetBundleName)
        end

        ET.Log.Info("Async load bundle BundleName : " .. p)

        -- if (!File.Exists(p))
        -- {
        --     Log.Error("Async load bundle not exist! BundleName : " + p);
        --     return null;
        -- }

        assetBundle = async:Await(ET.AssetBundleHelper.UnityLoadBundleAsync(p))

        if UnityEngine.Object.op_Equality(assetBundle, nil) then
          -- 获取资源的时候会抛异常，这个地方不直接抛异常，因为有些地方需要Load之后判断是否Load成功
          ET.Log.Warning("assets bundle not found: " .. assetBundleName)
          return nil
        end

        abInfo = ET.EntityFactory.CreateWithParent2(this, assetBundleName, assetBundle, false, ET.ABInfo, System.String, UnityEngine.AssetBundle)
        this.bundles:set(assetBundleName, abInfo)
        return abInfo
        --Log.Debug($"---------------load one bundle {assetBundleName} refcount: {abInfo.RefCount}");
      end, nil, this, assetBundleName)
    end
    LoadOneBundleAllAssets = function (this, abInfo)
      return System.async(function (async, this, abInfo)
        local default, extern = System.using(async:Await(ET.CoroutineLockComponent.Instance:Wait(ET.CoroutineLockType.Resources, abInfo.Name:GetHashCode(), 60000)), function ()
          if abInfo:getIsDisposed() or abInfo.AlreadyLoadAssets then
            return true
          end

          if UnityEngine.Object.op_Inequality(abInfo.AssetBundle, nil) and not abInfo.AssetBundle:getisStreamedSceneAssetBundle() then
            -- 异步load资源到内存cache住
            local assets = async:Await(ET.AssetBundleHelper.UnityLoadAssetAsync(abInfo.AssetBundle))

            for _, asset in System.each(assets) do
              AddResource(this, abInfo.Name, asset:getname(), asset)
            end
          end

          abInfo.AlreadyLoadAssets = true
        end)
        if default then
          return extern
        end
      end, nil, this, abInfo)
    end
    DebugString = function (this)
      local sb = System.StringBuilder()
      for _, abInfo in System.each(this.bundles:getValues()) do
        sb:Append(abInfo.Name .. ":" .. abInfo.RefCount .. "\n")
      end

      return sb:ToString()
    end
    class = {
      base = function (out)
        return {
          out.ET.Entity
        }
      end,
      Awake = Awake,
      Dispose = Dispose,
      Contains = Contains,
      GetBundleAll = GetBundleAll,
      GetAsset = GetAsset,
      UnloadBundles = UnloadBundles,
      UnloadBundle = UnloadBundle,
      LoadBundle = LoadBundle,
      LoadBundleAsync = LoadBundleAsync,
      DebugString = DebugString,
      __ctor__ = __ctor__
    }
    return class
  end)
end)
