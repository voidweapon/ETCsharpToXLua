-- Generated by CSharp.lua Compiler
local System = System
local UnityEngine = UnityEngine
System.namespace("ET", function (namespace)
  namespace.class("PositionHelper", function (namespace)
    local RayCastV2ToV3, RayCastXYToV3, RayCastV3ToV3, AngleToQuaternion, GetVector3ToQuaternion, Distance2D, Distance2D1, GetAngleToQuaternion, 
    Vector3ToAngle360, DistanceOfPointToVector, RayCastSphere, GGTheorem, IgnoreYAxis, PointOnLeftSideOfVector
    RayCastV2ToV3 = function (pos)
      return UnityEngine.Vector3(pos.x, 0, pos.y)
    end
    RayCastXYToV3 = function (x, y)
      return UnityEngine.Vector3(x, 0, y)
    end
    RayCastV3ToV3 = function (pos)
      return UnityEngine.Vector3(pos.x, 0, pos.z)
    end
    AngleToQuaternion = function (angle)
      return UnityEngine.Quaternion.op_Multiply(UnityEngine.Quaternion.AngleAxis(- angle, UnityEngine.Vector3.getup()), UnityEngine.Quaternion.AngleAxis(90, UnityEngine.Vector3.getup()))
    end
    GetVector3ToQuaternion = function (source, dire)
      local nowPos = source:__clone__()
      if UnityEngine.Vector3.op_Equality(nowPos, dire) then
        return UnityEngine.Quaternion()
      end
      local direction = (UnityEngine.Vector3.op_Subtraction(dire, nowPos)):getnormalized()
      return UnityEngine.Quaternion.LookRotation(direction, UnityEngine.Vector3.getup())
    end
    Distance2D = function (u1, u2)
      local v1 = UnityEngine.Vector2(u1:getPosition().x, u1:getPosition().z)
      local v2 = UnityEngine.Vector2(u2:getPosition().x, u2:getPosition().z)
      return UnityEngine.Vector2.Distance(v1, v2)
    end
    Distance2D1 = function (v1, v2)
      local d1 = UnityEngine.Vector2(v1.x, v1.z)
      local d2 = UnityEngine.Vector2(v2.x, v2.z)
      return UnityEngine.Vector2.Distance(d1, d2)
    end
    GetAngleToQuaternion = function (angle)
      return UnityEngine.Quaternion.op_Multiply(UnityEngine.Quaternion.AngleAxis(- angle, UnityEngine.Vector3.getup()), UnityEngine.Quaternion.AngleAxis(90, UnityEngine.Vector3.getup()))
    end
    Vector3ToAngle360 = function (from, to)
      local angle = UnityEngine.Vector3.Angle(from, to)
      local cross = UnityEngine.Vector3.Cross(from, to)
      return (cross.y > 0) and angle or (360 - angle)
    end
    -- <summary>
    -- 求点到直线的距离，采用数学公式Ax+By+C = 0; d = A*p.x + B * p.y + C / sqrt(A^2 + B ^ 2)
    -- </summary>
    -- <param name="startPoint"></param>
    -- <param name="endPoint"></param>
    -- <param name="point"></param>
    -- <returns></returns>
    DistanceOfPointToVector = function (startPoint, endPoint, point)
      local startVe2 = IgnoreYAxis(startPoint)
      local endVe2 = IgnoreYAxis(endPoint)
      local A = endVe2.y - startVe2.y
      local B = startVe2.x - endVe2.x
      local C = endVe2.x * startVe2.y - startVe2.x * endVe2.y
      local denominator = UnityEngine.Mathf.Sqrt(A * A + B * B)
      local pointVe2 = IgnoreYAxis(point)
      do
        return UnityEngine.Mathf.Abs((A * pointVe2.x + B * pointVe2.y + C) / denominator)
      end
    end
    -- <summary>
    -- 判断射线是否碰撞到球体，如果碰撞到，返回射线起点到碰撞点之间的距离
    -- </summary>
    -- <param name="ray"></param>
    -- <param name="center"></param>
    -- <param name="redius"></param>
    -- <param name="dist"></param>
    -- <returns></returns>
    RayCastSphere = function (ray, center, redius, dist)
      dist = 0
      local ma = UnityEngine.Vector3.op_Subtraction(center, ray:getorigin())
      local distance = UnityEngine.Vector3.Cross(ma, ray:getdirection()):getmagnitude() / ray:getdirection():getmagnitude()
      if distance < redius then
        local op = GGTheorem(UnityEngine.Vector3.Distance(center, ray:getorigin()), distance)
        local rp = GGTheorem(redius, distance)
        dist = op - rp
        return true, dist
      end
      return false, dist
    end
    -- <summary>
    -- 勾股定理
    -- </summary>
    -- <param name="x"></param>
    -- <param name="y"></param>
    -- <returns></returns>
    GGTheorem = function (x, y)
      return UnityEngine.Mathf.Sqrt(x * x + y * y)
    end
    -- <summary>
    -- 去掉三维向量的Y轴，把向量投射到xz平面。
    -- </summary>
    -- <param name="vector3"></param>
    -- <returns></returns>
    IgnoreYAxis = function (vector3)
      return UnityEngine.Vector2(vector3.x, vector3.z)
    end
    -- <summary>
    -- 判断目标点是否位于向量的左边
    -- </summary>
    -- <returns>True is on left, false is on right</returns>
    PointOnLeftSideOfVector = function (vector3, originPoint, point)
      local originVec2 = IgnoreYAxis(originPoint)

      local pointVec2 = (UnityEngine.Vector2.op_Subtraction(IgnoreYAxis(point), originVec2)):getnormalized()

      local vector2 = IgnoreYAxis(vector3)

      local verticalX = originVec2.x

      local verticalY = (- verticalX * vector2.x) / vector2.y

      local norVertical = (UnityEngine.Vector2(verticalX, verticalY)):getnormalized()

      local dotValue = UnityEngine.Vector2.Dot(norVertical, pointVec2)

      return dotValue < 0
    end
    return {
      RayCastV2ToV3 = RayCastV2ToV3,
      RayCastXYToV3 = RayCastXYToV3,
      RayCastV3ToV3 = RayCastV3ToV3,
      AngleToQuaternion = AngleToQuaternion,
      GetVector3ToQuaternion = GetVector3ToQuaternion,
      Distance2D = Distance2D,
      Distance2D1 = Distance2D1,
      GetAngleToQuaternion = GetAngleToQuaternion,
      Vector3ToAngle360 = Vector3ToAngle360,
      DistanceOfPointToVector = DistanceOfPointToVector,
      RayCastSphere = RayCastSphere,
      GGTheorem = GGTheorem,
      IgnoreYAxis = IgnoreYAxis,
      PointOnLeftSideOfVector = PointOnLeftSideOfVector
    }
  end)
end)
